PYTHON GEAVANCEERD - DECORATORS - GENERATORS - ASYNC

=== WAT ZIJN PYTHON DECORATORS? ===

Decorators zijn functies die andere functies "wrappen" om functionaliteit toe te voegen zonder de originele code te wijzigen.

Basis decorator voorbeeld:

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        print(f"{func.__name__} duurde {time.time() - start:.2f}s")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(1)

Hoe werkt een decorator:
1. @timer boven een functie plaatsen
2. Python vervangt de functie door wrapper
3. wrapper roept originele functie aan
4. Extra code wordt voor/na uitgevoerd

Keywords: decorator, @decorator, wrapper, functie wrappen

---

=== DECORATOR MET ARGUMENTEN ===

def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def say_hello():
    print("Hallo!")

# Roept say_hello 3 keer aan

---

=== WAT ZIJN PYTHON GENERATORS? ===

Generators zijn functies die waarden een voor een produceren met yield. Ze zijn memory-efficient voor grote datasets.

Generator functie:

def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

for num in fibonacci(10):
    print(num)

Voordelen van generators:
- Lazy evaluation (berekent on-demand)
- Zeer weinig geheugen nodig
- Kan oneindige sequenties maken

Generator expression:
squares = (x**2 for x in range(1000000))
# Neemt bijna geen geheugen!

Keywords: generator, yield, lazy evaluation, memory efficient

---

=== WAT ZIJN CONTEXT MANAGERS? ===

Context managers zorgen voor setup en cleanup code, vaak met "with" statement.

Class-based context manager:

class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode

    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()
        return False

with FileManager("test.txt", "r") as f:
    content = f.read()
# Bestand wordt automatisch gesloten

Keywords: context manager, with statement, __enter__, __exit__

---

=== PYTHON DATACLASSES ===

Dataclasses reduceren boilerplate voor data containers.

from dataclasses import dataclass, field
from typing import List

@dataclass
class User:
    naam: str
    email: str
    leeftijd: int = 0
    tags: List[str] = field(default_factory=list)

    def is_adult(self) -> bool:
        return self.leeftijd >= 18

# Automatisch gegenereerd: __init__, __repr__, __eq__

@dataclass(frozen=True)  # Immutable
class Point:
    x: float
    y: float

Keywords: dataclass, @dataclass, frozen, data container

---

=== PYTHON ASYNC/AWAIT ===

Async programming voor I/O-bound taken (netwerk, bestanden).

import asyncio
import aiohttp

async def fetch_url(url: str) -> str:
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.text()

async def fetch_all(urls: list) -> list:
    tasks = [fetch_url(url) for url in urls]
    return await asyncio.gather(*tasks)

# Uitvoeren
results = asyncio.run(fetch_all(["url1", "url2"]))

Wanneer async gebruiken:
- Netwerk requests
- Bestandsoperaties
- Database queries
- Meerdere taken parallel

Keywords: async, await, asyncio, concurrent, parallel

---

=== PYTHON TYPE HINTS ===

Type hints verbeteren leesbaarheid en IDE ondersteuning.

from typing import List, Dict, Optional, Callable

def process_items(
    items: List[str],
    callback: Callable[[str], int],
    config: Optional[Dict[str, any]] = None
) -> List[int]:
    return [callback(item) for item in items]

def get_user(user_id: int) -> Optional[User]:
    # Kan User of None teruggeven
    pass

Keywords: type hints, typing, Optional, List, Dict

---

=== HOE WERKT LRU_CACHE? ===

lru_cache is een Python decorator uit de functools module die functie-resultaten opslaat in een cache. LRU betekent "Least Recently Used".

Zo werkt lru_cache stap voor stap:
1. Eerste aanroep: functie wordt uitgevoerd, resultaat wordt opgeslagen in cache
2. Volgende aanroep met zelfde argumenten: resultaat komt direct uit cache (supersnel, geen berekening)
3. Cache vol? Oudste ongebruikte items worden automatisch verwijderd

Voorbeeld gebruik:
from functools import lru_cache

@lru_cache(maxsize=128)
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

Zonder cache duurt fibonacci(40) seconden. Met cache is het instant omdat eerder berekende waarden worden hergebruikt.

Parameters: maxsize=128 (max 128 resultaten), maxsize=None (onbeperkt), typed=True (types apart cachen).

Handig: fibonacci.cache_info() toont hits/misses, fibonacci.cache_clear() leegt de cache.

Wanneer gebruiken: dure berekeningen, recursieve functies, API calls die gecached mogen worden.

Keywords: lru_cache, cache, caching, memoization, functools, decorator, opslaan, hergebruiken

---

=== FUNCTOOLS PARTIAL ===

functools.partial maakt een nieuwe functie met sommige argumenten al ingevuld.

from functools import partial

def power(base, exponent):
    return base ** exponent

square = partial(power, exponent=2)
cube = partial(power, exponent=3)

print(square(5))  # 25
print(cube(3))    # 27

Keywords: partial, functools, argumenten, functie

---

=== FUNCTOOLS REDUCE ===

reduce past een functie cumulatief toe op een lijst.

from functools import reduce

# Product van alle getallen
product = reduce(lambda x, y: x * y, [1, 2, 3, 4, 5])
# 1*2=2, 2*3=6, 6*4=24, 24*5=120

Keywords: reduce, functools, cumulatief, lijst
