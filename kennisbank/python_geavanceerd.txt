PYTHON GEAVANCEERD - DECORATORS - GENERATORS - ASYNC

=== WAT ZIJN PYTHON DECORATORS? ===

Decorators zijn functies die andere functies "wrappen" om functionaliteit toe te voegen zonder de originele code te wijzigen.

Basis decorator voorbeeld:

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        print(f"{func.__name__} duurde {time.time() - start:.2f}s")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(1)

Hoe werkt een decorator:
1. @timer boven een functie plaatsen
2. Python vervangt de functie door wrapper
3. wrapper roept originele functie aan
4. Extra code wordt voor/na uitgevoerd

Keywords: decorator, @decorator, wrapper, functie wrappen

---

=== DECORATOR MET ARGUMENTEN ===

def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def say_hello():
    print("Hallo!")

# Roept say_hello 3 keer aan

---

=== WAT ZIJN PYTHON GENERATORS? ===

Generators zijn functies die waarden een voor een produceren met yield. Ze zijn memory-efficient voor grote datasets.

Generator functie:

def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

for num in fibonacci(10):
    print(num)

Voordelen van generators:
- Lazy evaluation (berekent on-demand)
- Zeer weinig geheugen nodig
- Kan oneindige sequenties maken

Generator expression:
squares = (x**2 for x in range(1000000))
# Neemt bijna geen geheugen!

Keywords: generator, yield, lazy evaluation, memory efficient

---

=== WAT ZIJN CONTEXT MANAGERS? ===

Context managers zorgen voor setup en cleanup code, vaak met "with" statement.

Class-based context manager:

class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode

    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()
        return False

with FileManager("test.txt", "r") as f:
    content = f.read()
# Bestand wordt automatisch gesloten

Keywords: context manager, with statement, __enter__, __exit__

---

=== PYTHON DATACLASSES ===

Dataclasses reduceren boilerplate voor data containers.

from dataclasses import dataclass, field
from typing import List

@dataclass
class User:
    naam: str
    email: str
    leeftijd: int = 0
    tags: List[str] = field(default_factory=list)

    def is_adult(self) -> bool:
        return self.leeftijd >= 18

# Automatisch gegenereerd: __init__, __repr__, __eq__

@dataclass(frozen=True)  # Immutable
class Point:
    x: float
    y: float

Keywords: dataclass, @dataclass, frozen, data container

---

=== PYTHON ASYNC/AWAIT ===

Async programming voor I/O-bound taken (netwerk, bestanden).

import asyncio
import aiohttp

async def fetch_url(url: str) -> str:
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.text()

async def fetch_all(urls: list) -> list:
    tasks = [fetch_url(url) for url in urls]
    return await asyncio.gather(*tasks)

# Uitvoeren
results = asyncio.run(fetch_all(["url1", "url2"]))

Wanneer async gebruiken:
- Netwerk requests
- Bestandsoperaties
- Database queries
- Meerdere taken parallel

Keywords: async, await, asyncio, concurrent, parallel

---

=== PYTHON TYPE HINTS ===

Type hints verbeteren leesbaarheid en IDE ondersteuning.

from typing import List, Dict, Optional, Callable

def process_items(
    items: List[str],
    callback: Callable[[str], int],
    config: Optional[Dict[str, any]] = None
) -> List[int]:
    return [callback(item) for item in items]

def get_user(user_id: int) -> Optional[User]:
    # Kan User of None teruggeven
    pass

Keywords: type hints, typing, Optional, List, Dict

---

=== FUNCTOOLS MODULE ===

import functools

# Caching met lru_cache
@functools.lru_cache(maxsize=128)
def expensive_calculation(n):
    return sum(i**2 for i in range(n))

# Partial functions
def power(base, exponent):
    return base ** exponent

square = functools.partial(power, exponent=2)
cube = functools.partial(power, exponent=3)

# Reduce
from functools import reduce
product = reduce(lambda x, y: x * y, [1, 2, 3, 4, 5])  # = 120

Keywords: functools, lru_cache, partial, reduce
